# 概要
このプロジェクトは、CLI上でのファイル操作を通してJava、OS、ハードウェアがどのように動いているのか学ぶプロジェクトとなっています。

# 作成したプロジェクト
各プログラムAIにコードレビューしてもらいやすいように

- program1
- program2
- program3

## program1
CLI上で入力を受け付けるプログラムを作成しました。

内容としては、二つの数字を受け取り、受け取った数字の間からランダムな数字を作成します。<br>
ユーザーは、作成された数字を当てるゲームとなっています。

## program2
CLI上でコマンドと指定されたファイルを受け取って、ファイルのコピーや反転などの操作を行うことができるプログラムを作成しました。

---

# 学んだ内容
ファイル操作を通して、どのようにプログラムが動いているのか大枠を把握することができました。

## プログラムの操作の流れ
Javaのプログラムは以下の流れで実行されます。

1. 準備と起動（ビルドとプロセスの誕生）

- コンパイル: 開発者が「Javaコンパイラ」を使い、ソースコードをJVMが理解できる「クラスファイル」に翻訳しておく。
- 起動: OSにJavaの実行を依頼すると、OSは専用の作業部屋であるプロセスを作成し、その中にJVM（Java仮想マシン）を住まわせ、最初の作業員であるmainスレッドを配置する。

2. 実行とOSへの依頼（システムコール）

- 制御: スレッド（作業員）がJVMの指示に従ってJavaコードを一行ずつ実行する。
- 依頼: ファイル読み込みなどのハードウェア操作が必要になると、スレッド（JVM）は自分では行わず、OSカーネルに「データをください」とリクエスト（システムコール）を送る。

3. データの旅（2つのメモリ空間）

- システム空間（カーネルキャッシュ）: OSカーネルがリクエストを受け、権限チェック等を行った後、ディスク等のハードウェアからデータを**ページ（小さな単位）**ごとに読み出し、OS管理下のメモリ領域に一時保存する。
- ユーザー空間（JVMメモリ領域）: OSが、システム空間にあるデータを**プロセスのメモリ（ユーザー空間）**へコピーする。ここで初めてJavaの「変数」や「配列」としてデータが扱えるようになる。

4. トラブルのメカニズム

- メモリ不足 (OutOfMemoryError): ユーザー空間（Java側）のメモリ容量以上に、データを一度にコピーしようとした（読み込もうとした）時に発生する。
- Nullポイント (NullPointerException): ユーザー空間において、データの「場所」を指し示すべき参照変数が、どこも指していない（null）状態で、その中身にアクセスしようとした時に発生する。

5. 効率的な通信と読み込み

- ストリーム（Stream）: 巨大なデータを一度にユーザー空間へコピーせず、OSから少量のデータをバケツリレーのように何度も繰り返してコピーすることで、メモリ不足を防ぐ手法。 
- パイプ (Pipe): プロセス間の片方向通信。一方のプロセスの「出口」と、もう一方の「入口」をOSが直結する。 
- ソケット (Socket): ネットワークを介した双方向通信。 
- FileChannelなど: OSとJavaのメモリの壁を越えて、コピーの手間を省く（ゼロコピー）などの高度で高速な通信を可能にする。


---

# パイプやソケットについて
## 1. パイプ（Pipe）：近距離の「伝言用土管」

同じコンピュータ内にある「プロセスA」と「プロセスB」を繋ぎ、データを一方通行で流す仕組みです。

* **イメージ**: 2つの部屋の間に壁に穴を開けて通した「土管」。
* **特徴**:
* **一方通行**: 基本的に「出す専用」と「受ける専用」に分かれます。
* **OS管理**: OSのメモリ上に一時的なバッファを作り、データを中継します。


* **Javaでの例**:
* `PipedOutputStream` と `PipedInputStream` を使って、同じプログラム内の別スレッド間でデータをやり取りする。
* シェルコマンド（例：`cat file | grep text`）のように、OSレベルでプロセスを繋ぐ。

## 2. ソケット（Socket）：遠距離の「双方向電話」

ネットワーク（LANやインターネット）を介して、別のコンピュータ上にあるプロセスと通信するための仕組みです。

* **イメージ**: コンピュータの壁にある「コンセントの差し込み口」。
* **特徴**:
* **双方向**: 1つの接続で、データの送りも受けも同時に行えます。
* **住所（IP）と番号（Port）**: 「どの家の（IPアドレス）」「どの窓口（ポート番号）」に繋ぐかを指定します。


* **Javaでの例**:
* `java.net.Socket` クラス。
* 接続が確立されると、そこから `getInputStream()` や `getOutputStream()` を取り出すことができ、ファイル操作と全く同じ感覚でデータを読み書きできます。

## 3. パイプとソケットの比較表

| 項目 | パイプ (Pipe) | ソケット (Socket) |
| --- | --- | --- |
| **接続範囲** | 同じPC内（同一OS内） | 別のPC（ネットワーク越し）も可能 |
| **方向** | 基本、一方通行（単方向） | **双方向** |
| **仕組み** | OSの共有メモリを使う | ネットワークカード(NIC)等を経由する |
| **Javaクラス** | `PipedInputStream` など | `Socket`, `ServerSocket` |

## 4. なぜ「ファイル操作」と同じ文脈で語られるのか？

Java（UNIX/LinuxというOS）の設計思想では、**「ファイルも、パイプも、ソケットも、すべてストリームとして扱える」**ようになっています。

* **ファイル**: ディスクへ繋がるストリーム
* **パイプ**: 隣のプロセスへ繋がるストリーム
* **ソケット**: 地球の裏側のサーバーへ繋がるストリーム

スレッド（作業員）から見れば、相手がハードディスクだろうが、隣のプロセスだろうが、アメリカにあるサーバーだろうが、「Streamという土管にデータを流し込む（または吸い出す）」という操作は全く同じ。

---

# メモ
ここからCSV・JSONファイルの読み込み・Zipファイルの対応などを行っても面白いかもしれない。
また巨大なデータをDBから取得する際に、ストリームを使うことも試すのもありかも。