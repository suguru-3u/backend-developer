はい、ご提供いただいた内容をMarkdown形式に整形します。

# N+1問題とその解決策

## 概要

**N+1問題**とは、データベースに対して発行した**一つの最初のSQL**に対し、その結果を利用して**さらにN個の追加のSQL**が発行されてしまう問題です。

例えば、「ユーザーとその投稿」を表示する場合を考えます。

1.  最初にすべてのユーザーを取得するSQLが**1回**発行されます。
2.  その後、取得した**各ユーザー**の投稿を取得するために、**N回**のSQLが発行されます。

これにより、データベースへのアクセス回数が大幅に増加し、アプリケーションのパフォーマンスが著しく低下します。

-----

## N+1問題の発生パターン（Sample）

以下の2つのクエリが、アプリケーションの処理によって連続して実行されます。

```sql
SELECT id FROM users;
-- 上記で取得されたidの数だけ、次のクエリが実行される (N回)
SELECT title, content FROM posts WHERE user_id = ?(上記クエリのid);
```

-----

## 解決策 1: SQLの結合（JOIN）

N+1問題を解決する最も基本的なSQL的手法は、**結合（JOIN）を使用することです。これにより、N回のクエリを1回**にまとめることができます。

```sql
SELECT u.name, p.title, p.content
FROM users u
LEFT JOIN posts p ON u.id = p.user_id;
```

-----

## 解決策 2: プリロード (Eager Loading / 積極的ロード)

結合以外には、**プリロード**（Eager Loading / 積極的ロード）と呼ばれる手法があります。

これは、**O/Rマッパー (ORM)** を使用するプログラミング言語（例: Ruby on Rails, Django, Laravel, JPAなど）で最も一般的に使用される解決策です。

### 概要

最初に親データ（例: 記事）を取得するときに、**関連する子データ（例: ユーザー情報）もまとめて**取得するようORMに指示します。これにより、ループ内で子データにアクセスする際に、追加のクエリが発行されるのを防ぎます。

### 動作の仕組み

通常、ORMは内部で**2回のクエリ**を発行してデータを取得します。

1.  **1回目:** 親データ（`posts`）を取得するクエリ。
2.  **2回目:** 取得した親データに紐づく**すべての子データ**（`users`）のIDを抽出し、それらを一括で取得するクエリ（例: `SELECT * FROM users WHERE id IN (1, 2, 1, 2, 1);` のように `IN`句を使用）。

### 利点

アプリケーションコードはシンプルに保たれ、ORMが自動的にデータの関連付けを行ってくれます。

詳細については、以下の記事なども参考にしてください。

> [https://zenn.dev/goldsaya/articles/3af48dadc6cc0f](https://zenn.dev/goldsaya/articles/3af48dadc6cc0f)